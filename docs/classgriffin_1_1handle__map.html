<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>griffin-containers: griffin::handle_map&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">griffin-containers
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>griffin</b></li><li class="navelem"><a class="el" href="classgriffin_1_1handle__map.html">handle_map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgriffin_1_1handle__map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">griffin::handle_map&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="handle__map_8h_source.html">handle_map.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgriffin_1_1handle__map_1_1_meta___t.html">Meta_T</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac24f3d12422a425b0426301f0178fa76"><td class="memItemLeft" align="right" valign="top"><a id="ac24f3d12422a425b0426301f0178fa76"></a>
typedef std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DenseSet_T</b></td></tr>
<tr class="separator:ac24f3d12422a425b0426301f0178fa76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0df9dd6b717014ec0b0dc90b57623e"><td class="memItemLeft" align="right" valign="top"><a id="a2b0df9dd6b717014ec0b0dc90b57623e"></a>
typedef std::vector&lt; <a class="el" href="structgriffin_1_1handle__map_1_1_meta___t.html">Meta_T</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MetaSet_T</b></td></tr>
<tr class="separator:a2b0df9dd6b717014ec0b0dc90b57623e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac26044b0bb6816a2cf83716b6bf1d4cd"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#ac26044b0bb6816a2cf83716b6bf1d4cd">at</a> (<a class="el" href="structgriffin_1_1_id___t.html">Id_T</a> handle)</td></tr>
<tr class="separator:ac26044b0bb6816a2cf83716b6bf1d4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1477db374a24463f88897f0e0a81ad3"><td class="memItemLeft" align="right" valign="top"><a id="ae1477db374a24463f88897f0e0a81ad3"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (<a class="el" href="structgriffin_1_1_id___t.html">Id_T</a> handle) const</td></tr>
<tr class="separator:ae1477db374a24463f88897f0e0a81ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1e2996849a2290fa7dda7bc539f098"><td class="memItemLeft" align="right" valign="top"><a id="a2b1e2996849a2290fa7dda7bc539f098"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (<a class="el" href="structgriffin_1_1_id___t.html">Id_T</a> handle)</td></tr>
<tr class="separator:a2b1e2996849a2290fa7dda7bc539f098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab731861a236090abe01b89561c8963"><td class="memItemLeft" align="right" valign="top"><a id="a0ab731861a236090abe01b89561c8963"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (<a class="el" href="structgriffin_1_1_id___t.html">Id_T</a> handle) const</td></tr>
<tr class="separator:a0ab731861a236090abe01b89561c8963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5541ad83c327beac2d6d5353b6a2e717"><td class="memTemplParams" colspan="2">template&lt;typename... Params&gt; </td></tr>
<tr class="memitem:a5541ad83c327beac2d6d5353b6a2e717"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgriffin_1_1_id___t.html">Id_T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#a5541ad83c327beac2d6d5353b6a2e717">emplace</a> (Params... args)</td></tr>
<tr class="separator:a5541ad83c327beac2d6d5353b6a2e717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf06d5cb4bba177b2b7f1a42bf32859e"><td class="memTemplParams" colspan="2">template&lt;typename... Params&gt; </td></tr>
<tr class="memitem:adf06d5cb4bba177b2b7f1a42bf32859e"><td class="memTemplItemLeft" align="right" valign="top">IdSet_T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#adf06d5cb4bba177b2b7f1a42bf32859e">emplaceItems</a> (int n, Params... args)</td></tr>
<tr class="separator:adf06d5cb4bba177b2b7f1a42bf32859e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaaf41138493de00272dc83b1956ae1a"><td class="memItemLeft" align="right" valign="top">DenseSet_T::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#aeaaf41138493de00272dc83b1956ae1a">begin</a> ()</td></tr>
<tr class="separator:aeaaf41138493de00272dc83b1956ae1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efb7d33b18c24898a9493e0013b521a"><td class="memItemLeft" align="right" valign="top"><a id="a0efb7d33b18c24898a9493e0013b521a"></a>
DenseSet_T::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const</td></tr>
<tr class="separator:a0efb7d33b18c24898a9493e0013b521a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae6cb2ddd4cda06ebfcf31a9dcac3d4"><td class="memItemLeft" align="right" valign="top"><a id="a0ae6cb2ddd4cda06ebfcf31a9dcac3d4"></a>
DenseSet_T::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:a0ae6cb2ddd4cda06ebfcf31a9dcac3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1f47a34c1d60455e88e28bd6a9b133"><td class="memItemLeft" align="right" valign="top"><a id="afa1f47a34c1d60455e88e28bd6a9b133"></a>
DenseSet_T::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const</td></tr>
<tr class="separator:afa1f47a34c1d60455e88e28bd6a9b133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0750504d50a26f1604070ad6859457d4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#a0750504d50a26f1604070ad6859457d4">erase</a> (<a class="el" href="structgriffin_1_1_id___t.html">Id_T</a> handle)</td></tr>
<tr class="separator:a0750504d50a26f1604070ad6859457d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad443754827c694139efa948f0daf71c7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#ad443754827c694139efa948f0daf71c7">eraseItems</a> (const IdSet_T &amp;handles)</td></tr>
<tr class="separator:ad443754827c694139efa948f0daf71c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d836ba56f34a3c2a30dea1354c6cb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgriffin_1_1_id___t.html">Id_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#a44d836ba56f34a3c2a30dea1354c6cb4">insert</a> (T &amp;&amp;i)</td></tr>
<tr class="separator:a44d836ba56f34a3c2a30dea1354c6cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14318e4014ff2f04c6bb54a05a204b64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgriffin_1_1_id___t.html">Id_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#a14318e4014ff2f04c6bb54a05a204b64">insert</a> (const T &amp;i)</td></tr>
<tr class="separator:a14318e4014ff2f04c6bb54a05a204b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade62e569d1a007255c639fd9af733644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#ade62e569d1a007255c639fd9af733644">clear</a> () _NOEXCEPT</td></tr>
<tr class="separator:ade62e569d1a007255c639fd9af733644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65dc8c5b3ae85ed34819538a94ed5e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#af65dc8c5b3ae85ed34819538a94ed5e8">reset</a> () _NOEXCEPT</td></tr>
<tr class="separator:af65dc8c5b3ae85ed34819538a94ed5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cc1ee12ed90b98d4ed08487b71690d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#a31cc1ee12ed90b98d4ed08487b71690d">isValid</a> (<a class="el" href="structgriffin_1_1_id___t.html">Id_T</a> handle) const</td></tr>
<tr class="separator:a31cc1ee12ed90b98d4ed08487b71690d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8860b01da4bd2239fc476d8c15c43e9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#af8860b01da4bd2239fc476d8c15c43e9">size</a> () const _NOEXCEPT</td></tr>
<tr class="separator:af8860b01da4bd2239fc476d8c15c43e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad566522bbc523495d39c3d5e4d818b10"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#ad566522bbc523495d39c3d5e4d818b10">capacity</a> () const _NOEXCEPT</td></tr>
<tr class="separator:ad566522bbc523495d39c3d5e4d818b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172209a72a3f2ea7515811d93e4c4ce7"><td class="memTemplParams" colspan="2">template&lt;typename Compare &gt; </td></tr>
<tr class="memitem:a172209a72a3f2ea7515811d93e4c4ce7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#a172209a72a3f2ea7515811d93e4c4ce7">defragment</a> (Compare comp, size_t maxSwaps=0)</td></tr>
<tr class="separator:a172209a72a3f2ea7515811d93e4c4ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e351b1de94096cfbe053cddac714ac"><td class="memItemLeft" align="right" valign="top">DenseSet_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#ae4e351b1de94096cfbe053cddac714ac">getItems</a> ()</td></tr>
<tr class="separator:ae4e351b1de94096cfbe053cddac714ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0b8ca633f950e26435f557818d5c42"><td class="memItemLeft" align="right" valign="top"><a id="acb0b8ca633f950e26435f557818d5c42"></a>
const DenseSet_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getItems</b> () const</td></tr>
<tr class="separator:acb0b8ca633f950e26435f557818d5c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886ce391520de20d896933f39d214749"><td class="memItemLeft" align="right" valign="top"><a id="a886ce391520de20d896933f39d214749"></a>
MetaSet_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getMeta</b> ()</td></tr>
<tr class="separator:a886ce391520de20d896933f39d214749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe834ea3bca0a315e05dd8eb7adca676"><td class="memItemLeft" align="right" valign="top"><a id="afe834ea3bca0a315e05dd8eb7adca676"></a>
const MetaSet_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getMeta</b> () const</td></tr>
<tr class="separator:afe834ea3bca0a315e05dd8eb7adca676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed3eb16b89ad0d10440aa3599c19c1b"><td class="memItemLeft" align="right" valign="top"><a id="a9ed3eb16b89ad0d10440aa3599c19c1b"></a>
IdSet_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getIds</b> ()</td></tr>
<tr class="separator:a9ed3eb16b89ad0d10440aa3599c19c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c64c06a115de93bcf17fc7020b0ad01"><td class="memItemLeft" align="right" valign="top"><a id="a6c64c06a115de93bcf17fc7020b0ad01"></a>
const IdSet_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getIds</b> () const</td></tr>
<tr class="separator:a6c64c06a115de93bcf17fc7020b0ad01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503d9812b211c44315091cbb445db33e"><td class="memItemLeft" align="right" valign="top"><a id="a503d9812b211c44315091cbb445db33e"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>getFreeListFront</b> () const</td></tr>
<tr class="separator:a503d9812b211c44315091cbb445db33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81aa1f17c7bdd879719cf846e79e5ebd"><td class="memItemLeft" align="right" valign="top"><a id="a81aa1f17c7bdd879719cf846e79e5ebd"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>getFreeListBack</b> () const</td></tr>
<tr class="separator:a81aa1f17c7bdd879719cf846e79e5ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a1d43caaf863769a412dfc03983653"><td class="memItemLeft" align="right" valign="top"><a id="a27a1d43caaf863769a412dfc03983653"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>getItemTypeId</b> () const</td></tr>
<tr class="separator:a27a1d43caaf863769a412dfc03983653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7afcea4fc6dfb9d8f49574580c7f634"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#aa7afcea4fc6dfb9d8f49574580c7f634">getInnerIndex</a> (<a class="el" href="structgriffin_1_1_id___t.html">Id_T</a> handle) const</td></tr>
<tr class="separator:aa7afcea4fc6dfb9d8f49574580c7f634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17c8070ac3688ab7ebd4c82afce307e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgriffin_1_1handle__map.html#af17c8070ac3688ab7ebd4c82afce307e">handle_map</a> (uint16_t itemTypeId, size_t reserveCount)</td></tr>
<tr class="separator:af17c8070ac3688ab7ebd4c82afce307e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class griffin::handle_map&lt; T &gt;</h3>

<p>Stores objects using a dense inner array and sparse outer array scheme for good cache coherence of the inner items. The sparse array contains handles (outer ids) used to identify the item, and provides an extra indirection allowing the inner array to move items in memory to keep them tightly packed. The sparse array contains an embedded FIFO freelist, where removed ids push to the back while new ids pop from the front.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of item to be stored </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af17c8070ac3688ab7ebd4c82afce307e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17c8070ac3688ab7ebd4c82afce307e">&sect;&nbsp;</a></span>handle_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::<a class="el" href="classgriffin_1_1handle__map.html">handle_map</a> </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>itemTypeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reserveCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itemTypeId</td><td>typeId used by the Id_T::typeId variable for this container </td></tr>
    <tr><td class="paramname">reserveCount</td><td>reserve space for inner storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac26044b0bb6816a2cf83716b6bf1d4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26044b0bb6816a2cf83716b6bf1d4cd">&sect;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgriffin_1_1_id___t.html">Id_T</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a direct reference to a stored item by handle </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>id of the item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the item </dd></dl>

</div>
</div>
<a id="aeaaf41138493de00272dc83b1956ae1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaaf41138493de00272dc83b1956ae1a">&sect;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DenseSet_T::iterator <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>iterators over the dense set, they are invalidated by inserting and removing </p>

</div>
</div>
<a id="ad566522bbc523495d39c3d5e4d818b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad566522bbc523495d39c3d5e4d818b10">&sect;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>capacity of the dense items array </dd></dl>

</div>
</div>
<a id="ade62e569d1a007255c639fd9af733644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade62e569d1a007255c639fd9af733644">&sect;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all items, leaving the m_sparseIds set intact by adding each entry to the free- list and incrementing its generation. This operation is slower than <code>reset</code>, but safer for the detection of stale handle lookups later (in debug builds). Prefer to use <code>reset</code> if safety is not a concern. Complexity is linear. </p>

</div>
</div>
<a id="a172209a72a3f2ea7515811d93e4c4ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172209a72a3f2ea7515811d93e4c4ce7">&sect;&nbsp;</a></span>defragment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::defragment </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSwaps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>defragment uses the comparison function <code>comp</code> to establish an ideal order for the dense set in order to maximum cache locality for traversals. The dense set can become fragmented over time due to removal operations. This can be an expensive operation, so the sort operation is reentrant. Use the <code>maxSwaps</code> parameter to limit the number of swaps that will occur before the function returns. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comp</td><td>comparison function object, function pointer, or lambda </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSwaps</td><td>maximum number of items to reorder in the insertion sort before the function returns. Pass 0 (default) to run until completion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Compare</td><td>comparison function object which returns ?true if the first argument is greater than (i.e. is ordered after) the second. The signature of the comparison function should be equivalent to the following: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> cmp(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b); </div></div><!-- fragment --> The signature does not need to have const &amp;, but the function object must not modify the objects passed to it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of swaps that occurred, keeping in mind that this value could overflow on very large data sets </dd></dl>

</div>
</div>
<a id="a5541ad83c327beac2d6d5353b6a2e717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5541ad83c327beac2d6d5353b6a2e717">&sect;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgriffin_1_1_id___t.html">Id_T</a> <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Params...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>create one item with default initialization </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Params</td><td>initialization arguments passed to constructor of item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id </dd></dl>

</div>
</div>
<a id="adf06d5cb4bba177b2b7f1a42bf32859e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf06d5cb4bba177b2b7f1a42bf32859e">&sect;&nbsp;</a></span>emplaceItems()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Params&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IdSet_T <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::emplaceItems </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Params...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>create n items with initialization args specified by Params, return vector of ids </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of items to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Params</td><td>initialization arguments passed to constructor of each item created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a collection of ids </dd></dl>

</div>
</div>
<a id="a0750504d50a26f1604070ad6859457d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0750504d50a26f1604070ad6859457d4">&sect;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgriffin_1_1_id___t.html">Id_T</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>remove the item identified by the provided handle </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>id of the item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of items removed (0 or 1) </dd></dl>

</div>
</div>
<a id="ad443754827c694139efa948f0daf71c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad443754827c694139efa948f0daf71c7">&sect;&nbsp;</a></span>eraseItems()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::eraseItems </td>
          <td>(</td>
          <td class="paramtype">const IdSet_T &amp;&#160;</td>
          <td class="paramname"><em>handles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>remove the items identified in the set of handles </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handles</td><td>set of ids </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of items removed </dd></dl>

</div>
</div>
<a id="aa7afcea4fc6dfb9d8f49574580c7f634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7afcea4fc6dfb9d8f49574580c7f634">&sect;&nbsp;</a></span>getInnerIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::getInnerIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgriffin_1_1_id___t.html">Id_T</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>index into the inner DenseSet for a given outer id </dd></dl>

</div>
</div>
<a id="ae4e351b1de94096cfbe053cddac714ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e351b1de94096cfbe053cddac714ac">&sect;&nbsp;</a></span>getItems()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DenseSet_T&amp; <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::getItems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>these functions provide direct access to inner arrays, don't add or remove items, just use them for lookups and iterating over the items </p>

</div>
</div>
<a id="a44d836ba56f34a3c2a30dea1354c6cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d836ba56f34a3c2a30dea1354c6cb4">&sect;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgriffin_1_1_id___t.html">Id_T</a> <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>add one item, forwarding the provided i into the store, return id </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>rvalue ref of of the object to move into inner storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id </dd></dl>

</div>
</div>
<a id="a14318e4014ff2f04c6bb54a05a204b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14318e4014ff2f04c6bb54a05a204b64">&sect;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgriffin_1_1_id___t.html">Id_T</a> <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>add one item, copying the provided i into the store, return id </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>const ref of of the object to copy into inner storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id </dd></dl>

</div>
</div>
<a id="a31cc1ee12ed90b98d4ed08487b71690d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31cc1ee12ed90b98d4ed08487b71690d">&sect;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::isValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgriffin_1_1_id___t.html">Id_T</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if handle handle refers to a valid item </dd></dl>

</div>
</div>
<a id="af65dc8c5b3ae85ed34819538a94ed5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65dc8c5b3ae85ed34819538a94ed5e8">&sect;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all items, destroying the m_sparseIds set. Leaves the container's capacity, but otherwise equivalent to a default-constructed container. This is faster than <code>clear</code>, but cannot safely detect lookups by stale handles obtained before the reset. Use <code>clear</code> if safety is a concern, at least until it's proven not to be a problem. Complexity is constant. </p>

</div>
</div>
<a id="af8860b01da4bd2239fc476d8c15c43e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8860b01da4bd2239fc476d8c15c43e9">&sect;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classgriffin_1_1handle__map.html">griffin::handle_map</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>size of the dense items array </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="handle__map_8h_source.html">handle_map.h</a></li>
<li>impl/<a class="el" href="handle__map-inl_8h_source.html">handle_map-inl.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
